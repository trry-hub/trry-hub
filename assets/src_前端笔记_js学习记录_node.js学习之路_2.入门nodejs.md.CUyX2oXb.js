import{_ as s,l as a,m as n,S as e}from"./chunks/framework.B9qehBrd.js";const i=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/前端笔记/js学习记录/node.js学习之路/2.入门nodejs.md","filePath":"src/前端笔记/js学习记录/node.js学习之路/2.入门nodejs.md","lastUpdated":1683717698000}');const p=s({name:"src/前端笔记/js学习记录/node.js学习之路/2.入门nodejs.md"},[["render",function(s,i,p,l,r,t){return n(),a("div",null,[...i[0]||(i[0]=[e('<h2 id="引擎" tabindex="-1">引擎 <a class="header-anchor" href="#引擎" aria-label="Permalink to &quot;引擎&quot;">​</a></h2><h3 id="v8-javascript-引擎" tabindex="-1">V8 javaScript 引擎 <a class="header-anchor" href="#v8-javascript-引擎" aria-label="Permalink to &quot;V8 javaScript 引擎&quot;">​</a></h3><hr><ol><li><p>V8 是为chrome提供支持的JavaScript引擎的名称。当使用Chrome进行浏览时，它负责处理并执行javaScript。</p></li><li><p>V8提供了执行javaScript的运行时环境。DOM和其他Web平台API则由浏览器提供。</p></li></ol><h3 id="其他js引擎" tabindex="-1">其他js引擎 <a class="header-anchor" href="#其他js引擎" aria-label="Permalink to &quot;其他js引擎&quot;">​</a></h3><p>其他的浏览器也有自己的javaScript引擎：</p><ul><li>Firefox 具有<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" target="_blank" rel="noreferrer">SpiderMonkey</a></li><li>Safari 具有<a href="https://developer.apple.com/documentation/javascriptcore" target="_blank" rel="noreferrer">javaScriptCore</a>(又称为Nitro)</li><li>Edge 具有<a href="https://github.com/Microsoft/ChakraCore" target="_blank" rel="noreferrer">Chakra</a></li></ul><h3 id="从命令行运行node-js脚本" tabindex="-1">从命令行运行node.js脚本 <a class="header-anchor" href="#从命令行运行node-js脚本" aria-label="Permalink to &quot;从命令行运行node.js脚本&quot;">​</a></h3><hr><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node 文件名</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="从node-js程序退出" tabindex="-1">从node.js程序退出 <a class="header-anchor" href="#从node-js程序退出" aria-label="Permalink to &quot;从node.js程序退出&quot;">​</a></h3><p>有很多中方法可以终止node.js应用程序.</p><ol><li>当控制太中运行程序时,可以使用 <code>ctrl-c</code> 将其关闭,但这是要讨论的是一编程的方式推出.</li><li>process 核心模块提供了一种便利的方法,可以以编程的方式退出node.js程序:process.exit(). 当node.js运行此行代码时,进程会被立即强制终止.</li></ol><blockquote><p>这意味着任何待处理的回调,仍在发送中的任何网络请求,任何文件系统访问,或正在写入 <code>stdout</code> 或 <code>stderr</code> 的进程,所有的这些都会被立即非正常的强制终止.</p></blockquote><p>3.可以传入一个整数,向操作系统发送退出码:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>process.exit(1)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>默认情况下,退出码为0,不同的推出码具有不同的含义,可以在系统中用与程序与其他程序的通信.</p><p>有关退出码的信息,详见<a href="http://nodejs.cn/api/process.html#process_exit_codes" target="_blank" rel="noreferrer">http://nodejs.cn/api/process.html#process_exit_codes</a></p><p>也可以设置 <code>process.exitCode</code> 属性:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>process.exitCode = 1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>当程序返回时,node.js 会返回该程序码.</p><p>当程序结束时,node.js也返回该退出码.当进程完成说有的处理后,程序会正常的退出.</p><h3 id="使用node-js启动服务器-例如http服务器" tabindex="-1">使用node.js启动服务器,例如HTTP服务器 <a class="header-anchor" href="#使用node-js启动服务器-例如http服务器" aria-label="Permalink to &quot;使用node.js启动服务器,例如HTTP服务器&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const express = require(&#39;exoress&#39;)</span></span>\n<span class="line"><span>const app = express()</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>app.get(&#39;/&#39;,(req,res) =&gt; {</span></span>\n<span class="line"><span>    res.send(&#39;你好&#39;)</span></span>\n<span class="line"><span>})</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>app.listen(3000, () =&gt; {</span></span>\n<span class="line"><span>    consoe.log(&#39;服务器已就绪&#39;)</span></span>\n<span class="line"><span>})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这个程序永远不会结束。如果调用 <code>process.exit()</code>,则任何当前等等待中或运行中的请求都会被中止。这不太友好。</p><p>在这种情况下，需要向该命令发送 SIGTERM 信号，并使用进程的信号处理程序进行处理:</p><blockquote><p>注意：<code>process</code> 不需要&quot;require&quot;,它是自动可用的。</p></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const express = require(&#39;express&#39;)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>const app = express()</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>app.get(&#39;/&#39;, (req, res) =&gt; {</span></span>\n<span class="line"><span>    res.send(&#39;你好&#39;)</span></span>\n<span class="line"><span>})</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>const server = app.listen(3000, () =&gt; console.log(&#39;服务器已就绪&#39;))</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>process.on(&#39;SIGTERM&#39;, () =&gt; {</span></span>\n<span class="line"><span>    server.close(() =&gt; {</span></span>\n<span class="line"><span>        console.log(&#39;进程已终止&#39;)</span></span>\n<span class="line"><span>    })</span></span>\n<span class="line"><span>})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><blockquote><p>什么是信号？ 信号是一个POSIX 内部通信系统：发送通知给进程，以告诉其发生的事件。</p></blockquote><ul><li><code>SIGKILL</code>是告诉进程要立即终止的信号，理想情况下，其行为类似于 <code>process.exit()</code>.</li><li><code>SIGTERM</code> 是告诉进程要正常终止的信号。它是从进程管理者（如<code>upstart</code>或<code>supervisord</code>）等发出的信号。</li></ul><p>可以从程序内部另一个函数中发送此信号：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>process.kill(process.pid, &#39;SIGTERM&#39;)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>或从另一个正在运行的Node.js程序、或从系统中运行的其他任何的应用程序（能知道要终止的进程的PID）。</p><h3 id="环境变量" tabindex="-1">环境变量 <a class="header-anchor" href="#环境变量" aria-label="Permalink to &quot;环境变量&quot;">​</a></h3><hr><h4 id="如何从node-js读取环境变量" tabindex="-1">如何从Node.js读取环境变量 <a class="header-anchor" href="#如何从node-js读取环境变量" aria-label="Permalink to &quot;如何从Node.js读取环境变量&quot;">​</a></h4><p>node.js的<code>process</code>核心模块提供了<code>env</code>属性，该属性承载了在启动进程时设置的所有环境变量。 这是访问NODE_ENV环境变量的示例，该环境变量默认情况下被设置为<code>development</code>。</p><blockquote><p>注意：<code>process</code>不需要&quot;require&quot;</p></blockquote><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>process.env.NODE_ENV  // &quot;development&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在脚本运行之前将其设置为&quot;production&quot;,则可告诉Node.js这是生产环境。</p><p>可以用相同的方式访问设置的任何自定义的环境变量。</p><h3 id="如何使用node-js-repl" tabindex="-1">如何使用Node.js REPL <a class="header-anchor" href="#如何使用node-js-repl" aria-label="Permalink to &quot;如何使用Node.js REPL&quot;">​</a></h3><hr><p>node命令是用来运行Node.js 脚本的命令：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node script.js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>如果省略文件名，则在REPL模式中使用它：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><blockquote><p>注意：REPL 也被称为运行评估打印循环，是一种编程语言环境（主要是控制台窗口），它使用单个表达式作为用户输入，并在执行后将结果返回到控制台。</p></blockquote><p>如果在终端中尝试，则会出现如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt; node</span></span>\n<span class="line"><span>&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>该命令会保持空闲状态，并等待输入内容。</p><ol><li>使用tab键自动补全</li><li>探索javascript对象</li><li>探索全局对象</li><li>_ 特殊变量</li><li>点命令</li></ol><h3 id="node-js-从命令行接收参数" tabindex="-1">Node.js 从命令行接收参数 <a class="header-anchor" href="#node-js-从命令行接收参数" aria-label="Permalink to &quot;Node.js 从命令行接收参数&quot;">​</a></h3><hr><p>当使用以下命令调用node.js应用程序时，可以传入任意数量的参数：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node app.js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>参数可以是独立的，也可以具有键和值。</p><p>例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node app.js joe</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>或</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node app.js name-joe</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这会改变在Node.js代码中获取参数值的方式。 获取参数值的方法是使用Node.js中内置的<code>process</code>对象。</p><p>它公开了<code>argv</code>属性，该属性是一个包含所有命令行调用参数的数组</p><p>第一个参数是<code>node</code>命令的完整路径。 第二个参数是正被执行的文件的完整路径。</p><p>所有其他的参数从第三个位置开始。</p><p>可以使用循环迭代所有的参数（包括 node 路径和文件路径）：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>process.argv.forEach((val, index) =&gt; {</span></span>\n<span class="line"><span>    console.log(`${index}:${val}`)</span></span>\n<span class="line"><span>})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>也可以通过创建一个排除了前两个参数的新数组来仅获取其他的参数：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const args = process.argv.slice(2)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>如果参数没有索引名称，例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node app.js joe</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>则可以这样访问：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const args = process.argv.slice(2)</span></span>\n<span class="line"><span>args[0]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果是这种情况：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node app.js name=joe</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>则<code>args[0]</code> 是<code>name=joe</code>,需要对其进行解析。最好的方法是使用<code>minimist</code>库，该库有助于处理参数：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const args = require(&#39;minimist&#39;)(process.argv.slice(2))</span></span>\n<span class="line"><span>args[&#39;name&#39;]//joe</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>但是需要在每个参数名称之前使用双破折号：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node app.js --name=joe</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="使用node-js-输出到命令行" tabindex="-1">使用Node.js 输出到命令行 <a class="header-anchor" href="#使用node-js-输出到命令行" aria-label="Permalink to &quot;使用Node.js 输出到命令行&quot;">​</a></h3><h4 id="使用控制台模块的基础输出" tabindex="-1">使用控制台模块的基础输出 <a class="header-anchor" href="#使用控制台模块的基础输出" aria-label="Permalink to &quot;使用控制台模块的基础输出&quot;">​</a></h4><p>Node.js 提供了 console模块，该模块提供了大量非常有用的与命令行交互的方法。</p><p>它基本上与浏览器中的console 对象相同。</p><p>最基础、最常用的方法是 console.log(),该方法会打印传入到控制台的字符串。</p><p>如果传入对象，则它会呈现为字符串。</p><p>可以传入多个变量到console.log，例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const x = &#39;x&#39;</span></span>\n<span class="line"><span>const y = &#39;y&#39;</span></span>\n<span class="line"><span>console.log(x, y)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Node.js 会全部打印出来。</p><p>也可以通过传入变量和格式说明符来格式化用语。</p><p>例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>console.log(&#39;我的%d岁&#39;, &#39;猫&#39;, 2)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li><code>%s</code>会格式化变量为字符串</li><li><code>%d</code>会格式化变量为数字</li><li><code>%i</code>会格式化变量为其整数部分</li><li><code>%o</code>会格式化变量为对象</li></ul><p>例如:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>console.log(&#39;%o&#39;,Number)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h4 id="清空控制台" tabindex="-1">清空控制台 <a class="header-anchor" href="#清空控制台" aria-label="Permalink to &quot;清空控制台&quot;">​</a></h4><p><code>console.clear()</code> 会清除控制台（其行为可能取决于所使用的控制台）。</p><h4 id="元素计数" tabindex="-1">元素计数 <a class="header-anchor" href="#元素计数" aria-label="Permalink to &quot;元素计数&quot;">​</a></h4><p><code>console.count()</code>是一个便利的方法。</p><p>使用以下代码：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const x = 1</span></span>\n<span class="line"><span>const y = 2</span></span>\n<span class="line"><span>const z = 3</span></span>\n<span class="line"><span>console.count(&#39;x 的值为 &#39; + x + &#39; 且已经检查了几次？ &#39;)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>console.count(&#39;x 的值为 &#39; + x + &#39; 且已经检查了几次？ &#39;)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>console.count(&#39; y 的值为 &#39; + y + &#39; 且已经检查了几次？ &#39;)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>count 方法会对打印的字符串的次数进行计数，并在其旁边打印计数：</p><p>数苹果和橙子：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const oranges = [&#39;橙子&#39;, &#39;橙子&#39;]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>const apples = [&#39;苹果&#39;]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>oranges.forEach(fruit =&gt; {</span></span>\n<span class="line"><span>    console.count(fruit)</span></span>\n<span class="line"><span>})</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>apples.forEach(fruit =&gt; {</span></span>\n<span class="line"><span>    console.count(fruit)</span></span>\n<span class="line"><span>})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="打印堆栈踪迹" tabindex="-1">打印堆栈踪迹 <a class="header-anchor" href="#打印堆栈踪迹" aria-label="Permalink to &quot;打印堆栈踪迹&quot;">​</a></h4><p>在某些情况下，打印函数的调用堆栈踪迹很有用，可以回答以下问题：如何到达代码的那一部分？ 可以使用console.trace()实现：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const function2 = () =&gt; console.trace()</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>const function1 = () =&gt; function2()</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>function1()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这会打印堆栈踪迹。如果在Node.js REPL 中尝试此操作，则会打印以下内容：</p><hr><h4 id="计算耗时" tabindex="-1">计算耗时 <a class="header-anchor" href="#计算耗时" aria-label="Permalink to &quot;计算耗时&quot;">​</a></h4><p>可以使用 <code>time()</code>和<code>timeEnd()</code>轻松的计算函数运行所需的时间:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const doSomething = () =&gt; console.log(&#39;测试&#39;)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>const measureDoingSomething = () =&gt; {</span></span>\n<span class="line"><span>    console.time(&#39;doSomething()&#39;)</span></span>\n<span class="line"><span>    // 做点事，并测量所需的时间</span></span>\n<span class="line"><span>    doSomething()</span></span>\n<span class="line"><span>    console.timeEnd(&#39;doSomething()&#39;)</span></span>\n<span class="line"><span>} </span></span>\n<span class="line"><span>measureDoingSomething()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="stdout-和-stderr" tabindex="-1">stdout 和 stderr <a class="header-anchor" href="#stdout-和-stderr" aria-label="Permalink to &quot;stdout 和 stderr&quot;">​</a></h4><p>console.log 非常适合在控制台中打印消息。这就是所谓的标准输出（或称为<code>stdout</code>）。</p><p><code>console.error</code> 会打印到 <code>stderr</code> 流。</p><p>他不会出现在控制台中，但是会出现在错误日志中。</p><h3 id="为输出着色" tabindex="-1">为输出着色 <a class="header-anchor" href="#为输出着色" aria-label="Permalink to &quot;为输出着色&quot;">​</a></h3><p>可以使用转义序列在控制台中为文本的输出着色。转义序列是一组标识颜色的字符串。</p><p>例如：</p><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\x1b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[33m%s</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\x1b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[0m&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;你好&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以在 Node.js REPL 中进行尝试，他会打印黄色的 <code>你好</code>.</p><p>当然，这是执行此操作的底层方法。为控制台输出着色的最简单方法是使用库。 <a href="https://github.com/chalk/chalk" target="_blank" rel="noreferrer">Chalk</a>是一个这样的库，除了为其着色外，它还有助于其他样式的设置（例如是文本变粗体、斜体或带下划线）。</p><p>可以使用<code>npm install chalk</code> 进行安装，然后就可以使用它：</p><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> chalk</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;chalk&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(chalk.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">yellow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;你好&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>与尝试记住转义代码相比，使用 <code>chalk.yellow</code>方便得多，并且代码更具有可读性。</p><h3 id="创建进度条" tabindex="-1">创建进度条 <a class="header-anchor" href="#创建进度条" aria-label="Permalink to &quot;创建进度条&quot;">​</a></h3><p><a href="https://www.npmjs.com/package/progress" target="_blank" rel="noreferrer">Progress</a>是一个很棒的软件包，可在控制台中创建进度条。使用<code>npm install progress</code> 进行安装。</p><p>一下代码段会创建一个 10 步的进度条，每 100 毫秒完成一步。当进度条结束时，则清楚定时器：</p><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ProgressBar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;progress&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ProgressBar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;:bar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { total: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> timer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    bar.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bar.complete) {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        clearInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="在node-js-中从命令行接收输入" tabindex="-1">在Node.js 中从命令行接收输入 <a class="header-anchor" href="#在node-js-中从命令行接收输入" aria-label="Permalink to &quot;在Node.js 中从命令行接收输入&quot;">​</a></h2><p>如何使用 Node.js CLI 程序具有交互性</p><p>从版本7开始，Node.js 提供了<code>readline</code> 模块来执行以下操作：每次一行地从可读流（例如<code>process.stdin</code>流，在Node.js程序执行期间该流就是终端输入）获取输入。</p><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> readline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;readline&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createInterface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    input: process.stdin,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    output: process.stdout</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}) </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">readline.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">question</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;你叫什么名字&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`你好 ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    readline.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这段代码会询问用户名，当输入了文本并且用户按下回车键时，则会发送问候语。</p><p><code>question()</code> 方法会显示第一个参数(即问题)，并等待用户的输入。当按下回车键时，则它会调用回调函数。</p><p>在此回调函数中，关闭了 readline 接口。</p><p><code>readline</code>还提供了其他几个方法</p><p>如果需要密码，则最好不要回显密码，而是显示<code>*</code>符号。</p><p>最简单的方式是使用<code>readline-sync</code>软件包，其在 API 方面非常相似。</p><p><a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="noreferrer">Inquirer.js软件包</a>则提供了更完整、更抽象的解决方案。</p><p>可以使用 <code>npm install inquirer</code> 进行安装，然后复用上面的代码如下：</p><div class="language-JavaScript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> inquirer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;inquirer&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> questions </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;input&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;name&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        message: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;你叫什么名字？&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">inquirer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prompt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(questions).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">answers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`你好 ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">answers</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;name&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}!`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>Inquirer.js 可以执行许多操作，例如询问多项选择、展示单选按钮、确认等。</p><p>所有的可选方案都值得了解，尤其是 Node.js 提供的内置方案，但是如果打算将CLI输入提升到更高的水平，则Inquirer.js是更优的选择。</p><h2 id="使用-exports-从-node-js-文件中公开功能" tabindex="-1">使用 exports 从 Node.js 文件中公开功能 <a class="header-anchor" href="#使用-exports-从-node-js-文件中公开功能" aria-label="Permalink to &quot;使用 exports 从 Node.js 文件中公开功能&quot;">​</a></h2><p>Node.js 具有内置的模块系统。</p><p>Node.js 文件可以导入其他Node.js文件公开的功能。</p><p>当想要导入某些东西时，使用</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const library = require(&#39;./library&#39;)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>可以导入存在于当前文件夹中的 <code>library.js</code>文件中公开的功能。</p><p>在此文件中，必须先公开功能，然后其它文件才能将其导入。</p><p>默认情况下，文件中定义的任何其他对象或变量都是私有的，不会公开给外界。</p><p>这就是 <code>module</code>系统提供的<code>module.exports</code>API可以做的事。</p><p>当将对象或函数赋值为新的<code>exports</code>属性时，这就是被公开的内容，因此，可以将其导入应用程序的其他部分或其他应用程序中</p>',153)])])}]]);export{i as __pageData,p as default};
