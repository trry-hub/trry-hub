import{_ as e,l as a,m as r,S as t}from"./chunks/framework.B9qehBrd.js";const o=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/前端笔记/vue/vue2.x/缓存某个页面的操作.md","filePath":"src/前端笔记/vue/vue2.x/缓存某个页面的操作.md","lastUpdated":1683717698000}');const n=e({name:"src/前端笔记/vue/vue2.x/缓存某个页面的操作.md"},[["render",function(e,o,n,i,l,d){return r(),a("div",null,[...o[0]||(o[0]=[t('<h2 id="需求" tabindex="-1">需求 <a class="header-anchor" href="#需求" aria-label="Permalink to &quot;需求&quot;">​</a></h2><p>缓存 A 页面，进入 B 页面进行一些操作后，返回 A 页面能继续之前的操作 场景： 1、列表页，根据条件搜索、翻页后，点击某条记录进编辑页操作，操作完毕后退回列表页，要保持之前的搜索条件和页数 2、表单页，一些下拉选择框里的数据是读取别的模块的记录，一般会在表单里放个快捷入口，点击跳转过去进行新增或编辑，操作完毕后返回表单，需要保留之前表单已填数据</p><h3 id="keep-alive" tabindex="-1">keep-alive <a class="header-anchor" href="#keep-alive" aria-label="Permalink to &quot;keep-alive&quot;">​</a></h3><pre><code>优势：\n1、体验上最佳，keep-alive 天然为组件缓存而提供\n2、可以实现更为复杂的缓存效果，例如 A 页面-&gt;B 页面需要将 A 页面缓存，A 页面-&gt;C 页面不需要对 A 页面缓存\n劣势：\n1、对 A、B 两个页面的路由配置有一定要求，例如 B 页面需要与 A 页面同级或者是 A 页面的下级\n2、对开发人员理解 keep-alive 的机制有一定要求\n</code></pre><h3 id="弹框" tabindex="-1">弹框 <a class="header-anchor" href="#弹框" aria-label="Permalink to &quot;弹框&quot;">​</a></h3><pre><code>优势：\n1、弹框的思路就是将 A、B 两个页面变成一个页面，所以不存在需不需要缓存 A 页面的问题，因为始终都在 A 页面\n劣势：\n1、无法直接访问 B 页面的内容，当然也可以通过给 A 页面路由增加 query 的方式，实现访问自动打开弹框，但实际上列表页也已经加载好了，无形中增加了不必要的网络请求\n</code></pre><h3 id="嵌套路由-b-页面为-a-页面的子路由-需要在-a-页面里增加-router-view" tabindex="-1">嵌套路由（B 页面为 A 页面的子路由，需要在 A 页面里增加<code>&lt;router-view /&gt;</code>） <a class="header-anchor" href="#嵌套路由-b-页面为-a-页面的子路由-需要在-a-页面里增加-router-view" aria-label="Permalink to &quot;嵌套路由（B 页面为 A 页面的子路由，需要在 A 页面里增加`&lt;router-view /&gt;`）&quot;">​</a></h3><pre><code>优势：\n1、和弹框相比，B 页面有独立的路由地址，可以直接访问\n劣势：\n1、由于 B 页面是子路由，所以即便直接访问，A 页面的生命周期依旧会触发，与弹框方案的问题类似（当然这个问题可以通过 if 条件去限制，但代码会比较臃肿）\n</code></pre><p>cookie 等数据缓存方案不在讨论范围内</p>',9)])])}]]);export{o as __pageData,n as default};
