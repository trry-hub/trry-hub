import{_ as s,l as n,m as a,S as e}from"./chunks/framework.B9qehBrd.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/前端笔记/vue/vue2.x/自定义事件.md","filePath":"src/前端笔记/vue/vue2.x/自定义事件.md","lastUpdated":1683717698000}');const l=s({name:"src/前端笔记/vue/vue2.x/自定义事件.md"},[["render",function(s,p,l,i,t,c){return a(),n("div",null,[...p[0]||(p[0]=[e('<h3 id="事件名" tabindex="-1">事件名 <a class="header-anchor" href="#事件名" aria-label="Permalink to &quot;事件名&quot;">​</a></h3><hr><p>不同于组件和prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>this.$emit(&#39;myEvent&#39;)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>则监听这个名字的kebab-case版本是不会有任何效果的：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;!-- 没有效果 --&gt;</span></span>\n<span class="line"><span>&lt;my-component v-on:my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>不同于组件和prop，事件名不会被作一个javaScript 变量名或property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 v-on 事件监听器在DOM模板中会被自动转换为全小写（因为HTML是大小写不敏感的），所以 v-on:myEvent 将会变成 v-on:myevent ----导致myEvent 不可能被监听到。</p><p>因此，我们推荐你始终使用 kebab-case 的事件名。</p><h3 id="自定以组件的v-model" tabindex="-1">自定以组件的<code>v-model</code> <a class="header-anchor" href="#自定以组件的v-model" aria-label="Permalink to &quot;自定以组件的```v-model```&quot;">​</a></h3><hr><p>一个组件上的 v-model 默认会利用名为 value 的prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。 model 选项可以用来避免这样的冲突：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Vue.component(&#39;base-checkbox&#39;,{</span></span>\n<span class="line"><span>    model: {</span></span>\n<span class="line"><span>        prop: &#39;checked&#39;,</span></span>\n<span class="line"><span>        event: &#39;change&#39;</span></span>\n<span class="line"><span>    },</span></span>\n<span class="line"><span>    props: {</span></span>\n<span class="line"><span>        checked: Boolean</span></span>\n<span class="line"><span>    },</span></span>\n<span class="line"><span>    template: `&lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;checked&quot; v-on:change=&quot;$emit(&#39;change&#39;, $event.target.checked)&quot;&gt;`</span></span>\n<span class="line"><span>})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>现在在这个组件上使用 v-model 的时候:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的prop 。同时当 <code>&lt;base-checkbox&gt;</code>触发一个 <code>change</code>事件并附带一个新的值的时候，这个 <code>lovingVue</code>的 property 将会被更新。</p><blockquote><p>注意你仍然需要在组件的<code>props</code>选项里声明checked这个prop。</p></blockquote><h3 id="将原生事件绑定到组件" tabindex="-1">将原生事件绑定到组件 <a class="header-anchor" href="#将原生事件绑定到组件" aria-label="Permalink to &quot;将原生事件绑定到组件&quot;">​</a></h3><hr><p>你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用<code>v-on</code>的 <code>.native</code>修饰符：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;base-input v-on:focus.native=&quot;onFocus&quot;&gt;&lt;/base-input&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在有的时候这是很有用的，不过在你尝试监听一个类似<code>&lt;input&gt;</code>的非特定的元素时，这并不是个好主意。比如上述<code>&lt;base-input&gt;</code>组件可能做了如下重构，所以根元素实际上市一个<code>&lt;label&gt;</code>元素：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;label&gt;</span></span>\n<span class="line"><span>    {{ label }}</span></span>\n<span class="line"><span>    &lt;input</span></span>\n<span class="line"><span>        v-bind=&quot;$attrs&quot;</span></span>\n<span class="line"><span>        v-bind:value=&quot;value&quot;</span></span>\n<span class="line"><span>        v-on:input=&quot;$emit(&#39;input&#39;, $event.target.value)&quot;</span></span>\n<span class="line"><span>    &gt;</span></span>\n<span class="line"><span>&lt;/label&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这时，父级的<code>.native</code>监听器将静默失败。它不会产生任何报错，但是<code>onFocus</code>处理函数不会如你预期的被调用。</p><p>为了解决这个问题，Vue 提供了一个<code>$listeners</code> property, 他是一个对象，里面包含了作用在这个组件上的所有监听器。例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{</span></span>\n<span class="line"><span>    focus: function (event) {}</span></span>\n<span class="line"><span>    input: function (value) {},</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>有了这个<code>$listenerss</code> property, 你就可以配合<code>v-on=&quot;$listeners&quot;</code>将所有的事件监听器指向这个组件的某个特定的子元素。对于类似<code>&lt;input&gt;</code>的你希望它可以配合<code>v-model</code>工作的组件来说，为这些监听器创建一个类似下述 <code>inputListeners</code> 的计算属性通常是非常有用的：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Vue.component(&#39;base-input&#39;, {</span></span>\n<span class="line"><span>    inheritAttrs: false,</span></span>\n<span class="line"><span>    props: [&#39;label&#39;, &#39;value&#39;],</span></span>\n<span class="line"><span>    computed: {</span></span>\n<span class="line"><span>        inputListeners: function () {</span></span>\n<span class="line"><span>            var vm = this</span></span>\n<span class="line"><span>            // `Object.assign` 将所有的对象合并为一个新对象</span></span>\n<span class="line"><span>            return Object.assign({},</span></span>\n<span class="line"><span>            // 我们从父级添加所有的监听器</span></span>\n<span class="line"><span>            this.$listeners,</span></span>\n<span class="line"><span>            // 然后我们添加自定义监听器，</span></span>\n<span class="line"><span>            //或覆写一些监听器的行为</span></span>\n<span class="line"><span>            {</span></span>\n<span class="line"><span>                // 这里确保组件配合 `v-model` 的工作</span></span>\n<span class="line"><span>                input: function (event) {</span></span>\n<span class="line"><span>                    vm.$emit(&#39;input&#39;, event.target.value)</span></span>\n<span class="line"><span>                }</span></span>\n<span class="line"><span>            }</span></span>\n<span class="line"><span>            )</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>    },</span></span>\n<span class="line"><span>    template: `&lt;label&gt;</span></span>\n<span class="line"><span>      {{ label }}</span></span>\n<span class="line"><span>      &lt;input</span></span>\n<span class="line"><span>        v-bind=&quot;$attrs&quot;</span></span>\n<span class="line"><span>        v-bind:value=&quot;value&quot;</span></span>\n<span class="line"><span>        v-on=&quot;inputListeners&quot;</span></span>\n<span class="line"><span>      &gt;</span></span>\n<span class="line"><span>    &lt;/label&gt;`</span></span>\n<span class="line"><span>})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>现在 <code>&lt;base-input&gt;</code>组件时一个完全透明的包裹器了，也就是说它可以完全像一个普通的<code>&lt;input&gt;</code>元素一样使用了：所有跟他相同的attribute和监听器都可以工作。</p><h3 id="sync修饰符" tabindex="-1"><code>.sync</code>修饰符 <a class="header-anchor" href="#sync修饰符" aria-label="Permalink to &quot;```.sync```修饰符&quot;">​</a></h3><hr><p>在有些情况下，我们可能需要对一个prop进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以变父组件，且在父组件和子组件都没有明显的变更来源。</p><p>这也是为什么我们推荐<code>update:myPropName</code> 的模式触发事件取而代之。举个例子，在一个包含<code>title</code> prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>this.$emit(&#39;update:title&#39;, newTitle)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>然后父组件可以监听那个事件并根据需要更新一个本地的数据 property 。 例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;text-dovument</span></span>\n<span class="line"><span>    v-bind:title=&quot;doc.title&quot;</span></span>\n<span class="line"><span>    v-on:update:title=&quot;dov.title = $event&quot;</span></span>\n<span class="line"><span>&gt;&lt;/text-document&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>为了方便起见，我们为这种模式提供了一个缩写，即<code>.sync</code>修饰符：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;text-document v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><blockquote><p>注意带有 <code>.sync</code>修饰符的 <code>v-bind</code> 不能和表达式一起使用（例如 <code>v-bind:title.sync=&quot;doc.title + &#39;!&#39;&quot;</code>是无效的）。取而代之的是，你只能提供你想要绑定的 property 名，类似 <code>v-model</code>.</p></blockquote><p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 <code>.sync</code> 修饰符和 <code>v-bind</code> 配合使用：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;text-document v-bing.sync=&quot;doc&quot;&gt;&lt;/text-document&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这样会把 <code>doc</code> 对象中的每一个property (如 <code>title</code>)都作为一个独立的prop传过去，然后各自添加用于更新的 <code>v-on</code> 监听器。</p><blockquote><p>将 <code>v-bind.sync</code>用在一个字面量的对象上，例如 <code>v-bind.sync=&quot;{ title: doc.title }&quot;</code>, 是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p></blockquote>',42)])])}]]);export{p as __pageData,l as default};
